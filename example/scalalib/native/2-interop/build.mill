package build
import mill._, scalalib._, scalanativelib._

object `package` extends RootModule with ScalaNativeModule {
  def scalaVersion = "2.13.11"
  def scalaNativeVersion = "0.5.5"

  object test extends ScalaNativeTests {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest::0.8.4")
    def testFramework = "utest.runner.Framework"
  }
  
  def nativeLinking = true
  def nativeLinkingOptions = Seq("-L" + millSourcePath.toString + "/target")

  // Compiled C
  def nativeCompiled = T {
    os.makeDir.all(millSourcePath / "target")

    os.proc("gcc", "-m64", "-shared",
      "-c", millSourcePath.toString + "/native-src/HelloWorld.c",
      "-o", millSourcePath.toString + "/target/libHelloWorld.so"
    ).call(stdout = os.Inherit)

    PathRef(T.dest / "target/libHelloWorld.so")    
  }
}


// This is an example of how to use Mill to compile C code together with your Scala Native
// code.
//
// The above build expect the following project layout:
//
// ----
// build.mill
// src/
//	foo/
//	    HelloWorld.scala
//
// native-src/
//	HelloWorld.c
//
// test/
//     src/
//         foo/
//             HelloWorldTests.scala
// ----
//
// This example is pretty minimal, but it demonstrates the core principles, and
// can be extended if necessary to more elaborate use cases. The `native*` tasks
// can also be extracted out into a `trait1 for re-use if you have multiple
// `ScalaNativeModule`s that need native C components.

/** Usage

> ./mill nativeCompiled
...
#1 [info] done compiling
#1 [1/1] nativeCompiled

> ./mill run
...
#2 [info] Compiling to native code (4749 ms)
#2 [info] Linking with [pthread, dl, HelloWorld]
#2 [info] Linking native code (immix gc, none lto) (117 ms)
#2 [info] Postprocessing (0 ms)
#2 [info] Total (11344 ms)
[90/1] run 
Running HelloWorld function
Done...
Reversed: !dlroW ,olle

> ./mill test


*/
