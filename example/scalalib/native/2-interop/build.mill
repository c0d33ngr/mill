package build
import mill._, scalalib._, scalanativelib._

object `package` extends RootModule with ScalaNativeModule {
  def scalaVersion = "2.13.11"
  def scalaNativeVersion = "0.5.5"

  object test extends ScalaNativeTests {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest::0.8.4")
    def testFramework = "utest.runner.Framework"
  }

  // Additional source folder to put C sources
  def nativeSources = Task.Sources(millSourcePath / "resources/scala-native")

  def nativeLinkingOptions = Seq("-L" + Task.dest.toString)

  // Compiled C
  def nativeCompiled = Task {
    val cSourceFiles = nativeSources().map(_.path).flatMap(os.walk(_)).filter(_.ext == "c")
    val output = "libHelloWorld.so"
  
    os.proc("gcc", "-m64", "-shared",
      "-c", cSourceFiles,
      "-o", output
    ).call(stdout = os.Inherit)

    PathRef(Task.dest / output)
  }
}


// This is an example of how to use Mill to compile C code together with your Scala Native
// code.
//
// The above build expect the following project layout:
//
// ----
// build.mill
// src/
//	foo/
//	    HelloWorld.scala
//
// resources/
//     scala-native/
//         HelloWorld.c
//
// test/
//     src/
//         foo/
//             HelloWorldTests.scala
// ----
//
// This example is pretty minimal, but it demonstrates the core principles, and
// can be extended if necessary to more elaborate use cases.

/** Usage

> ./mill nativeCompiled
...

> ./mill run
Running HelloWorld function
Done...
Reversed: !dlroW ,olleH

> ./mill test
Tests: 1, Passed: 1, Failed: 0

*/
