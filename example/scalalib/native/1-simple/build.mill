//// SNIPPET:BUILD
package build
import mill._, scalalib._, scalanativelib._

object `package` extends RootModule with ScalaNativeModule {
  def scalaVersion = "2.13.11"
  def scalaNativeVersion = "0.5.5"

  // You can have arbitrary numbers of third-party dependencies
  def ivyDeps = Agg(
    ivy"com.lihaoyi::fansi::0.5.0",
    ivy"com.lihaoyi::mainargs::0.7.6"
  )

  def nativeLinking = true
  object test extends ScalaNativeTests {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest::0.8.4")
    def testFramework = "utest.runner.Framework"
  }
}

// This is a basic Mill build for a single `ScalaNativeModule`, with two
// third-party dependencies and a test suite using the uTest framework. As a
// single-module project, it `extends RootModule` to mark ``object `package``` as the
// top-level module in the build. This lets us directly perform operations
// `./mill compile` or `./mill run` without needing to prefix it as
// `foo.compile` or `foo.run`.
//
//// SNIPPET:TREE
// ----
// build.mill
// src/
//     Foo.scala
//     ...
// test/
//     src/
//         FooTests.scala
// out/
//     compile.json
//     compile.dest/
//     ...
//     test/
//         compile.json
//         compile.dest/
//         ...
// ----
//

//// SNIPPET:END

//
// You can download this example project using the *download* link above
// if you want to try out the commands below yourself. The only requirement is
// that you have some version of the JVM installed; the `./mill` script takes
// care of any further dependencies that need to be downloaded.
//
// The source code for this module lives in the `src/` folder.
// Output for this module (compiled files, resolved dependency lists, ...)
// lives in `out/`.
//
//// SNIPPET:DEPENDENCIES
//
//
/** Usage

> ./mill resolve _ # List what tasks are available to run
assembly
...
clean
...
compile
...
run
...
show
...
inspect
...

> ./mill run --text hello
...
#1 [info] Linking native code (immix gc, none lto) (185 ms)
#1 [info] Postprocessing (0 ms)
#1 [info] Total (24202 ms)
[90/1] run 
<h1>hello</h1>

> ./mill nativeLink  # Build and link native binary
...
#2 [info] done compiling
#2 [85/85] nativeLink 
#2 [info] Linking (multithreadingEnabled=true, disable if not used) (2509 ms)
#2 [info] Discovered 1351 classes and 10597 methods after classloading
#2 [info] Checking intermediate code (quick) (260 ms)
#2 [info] Multithreading was not explicitly enabled - initial class loading has not detected any usage of system threads. Multithreading support will be disabled to improve performance.
#2 [info] Linking (multithreadingEnabled=false) (2037 ms)
#2 [info] Discovered 1182 classes and 9352 methods after classloading
#2 [info] Checking intermediate code (quick) (32 ms)
#2 [info] Discovered 1162 classes and 7192 methods after optimization
#2 [info] Optimizing (debug mode) (6107 ms)
...

> ./mill releaseMode # Specifies the `releaseMode`. Default releaseMode is set to Debug.
...
#1 [2/2] releaseMode 

> ./mill nativeOptimize # Set native optimization. The Default value is true.
...
#2 [info] done compiling
#1 [2/2] nativeOptimize 

> ./mill nativeIncrementalCompilation # Set native incremental compilation. It recompiles only changed files. Default is false.  
[build.mill] #2 [55/59] compile 
...
#2 [info] done compiling
#1 [1/1] nativeIncrementalCompilation

> ./mill nativeLinkingOptions # Set path to native linking options. Default path is `"-L/usr/local/lib`.
[build.mill] #1 [55/59] compile
...
#1 [info] done compiling
#1 [7/7] nativeLinkingOptions

*/

//// SNIPPET:END

//
// You can run `+mill resolve __+` to see a full list of the different tasks that
// are available, `+mill resolve _+` to see the tasks within `foo`,
// `mill inspect compile` to inspect a task's doc-comment documentation or what
// it depends on, or `mill show foo.scalaVersion` to show the output of any task.
//
// The most common *tasks* that Mill can run are cached *targets*, such as
// `compile`, and un-cached *commands* such as `foo.run`. Targets do not
// re-evaluate unless one of their inputs changes, whereas commands re-run every
// time.

